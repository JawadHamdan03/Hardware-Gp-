#include <Servo.h>
#include <PN532_HSU.h>
#include <PN532.h>
#include <AccelStepper.h>
#include <LiquidCrystal_I2C.h>
#include <math.h>    // for fabs

// ============================
//          LCD SETTINGS
// ============================

// I2C 16x2 LCD at address 0x27
LiquidCrystal_I2C lcd(0x27, 16, 2);
void lcdStatus(const char* line1, const char* line2) {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(line1);
  lcd.setCursor(0, 1);
  lcd.print(line2);
}

// Overloads for String
void lcdStatus(const String &l1, const String &l2) {
  lcdStatus(l1.c_str(), l2.c_str());
}

// ============================
//   ESP32 <-> MEGA SERIAL LINK
// ============================

// نستخدم Serial2 للاتصال مع ESP32
// على Arduino Mega: RX2 = 17, TX2 = 16
#define ESP_SERIAL Serial2
const long ESP_BAUD = 115200;

// ============================
//       ARM STEPPER SETTINGS
// ============================

// Pins (ARM X-axis)
const int DIR_PIN = 2;
const int STEP_PIN = 3;
const int ENABLE_PIN = 4;
const int LIMIT_SWITCH_PIN = 10;

// Steps per cm (ARM)
const int STEPS_PER_CM = 50;

// Column positions (absolute from home in cm)
const float COL_ABS_CM[4] = {8, 22, 36, 50};
const int NUM_COLUMNS = 4;

// Rows
const int NUM_ROWS = 3;

// Stepper speed profile (ARM)
const int TRAP_DELAY_START_US = 1500;
const int TRAP_DELAY_MIN_US   = 600;
const float TRAP_RAMP_FRACTION = 0.2;
const bool DIR_AWAY_FROM_HOME = HIGH;
const bool DIR_TOWARD_HOME    = LOW;
const int BACKOFF_STEPS       = 50;

// Track current step position from home (ARM)
long currentStepPos = 0;

// ============================
//         SERVO SETTINGS
// ============================

Servo s1, s2, s3, s4, s5, s6;
const int S1_PIN = 11, S2_PIN = 12, S3_PIN = 13, S4_PIN = 50, S5_PIN = 51, S6_PIN = 24;

// Default pose (global default)
int s1Pos = 100;
int s2Pos = 90;
int s3Pos = 90;
int s4Pos = 100;
int s5Pos = 10;
int s6Pos = 65;

const float SERVO_SPEED_DPS_DEFAULT = 35.0f;

// ============================
//       CONVEYOR SETTINGS
// ============================

// Conveyor stepper pins
#define CONV_DIR_PIN   5
#define CONV_STEP_PIN  6
#define CONV_EN_PIN    7

// EN polarity (MOST drivers A4988/DRV8825 are ACTIVE LOW)
const bool CONV_EN_ACTIVE_LOW = true;   // if motor still hums when idle, try false

// LDR sensors
#define LDR1_PIN  9   // start sensor
#define LDR2_PIN  8   // end sensor

// Conveyor logic
const bool LDR_ACTIVE_LOW = true;   // LOW = object present

// Conveyor speed / accel
const float STEPPER_SPEED = 1500.0;   // steps/s
const float STEPPER_ACCEL = 800.0;    // steps/s^2

// You set this to ~12 cm
const long STEPS_PER_12CM = 550;

// LDR filtering
const uint8_t LDR_SAMPLES   = 3;
const uint8_t LDR_SAMPLE_MS = 1;      // total ~3ms

// PN532 (RFID)
PN532_HSU pn532hsu(Serial1);
PN532 nfc(pn532hsu);

// Conveyor stepper
AccelStepper conveyorStepper(AccelStepper::DRIVER, CONV_STEP_PIN, CONV_DIR_PIN);

// Conveyor state machine
enum RunState {
  IDLE,         // waiting for object at LDR1
  MOVE_12CM,    // move 12 cm after LDR1
  WAIT_RFID,    // try to read RFID tag
  MOVING,       // moving forward after reading tag
  STOPPED       // stopped at LDR2
};
RunState convState = IDLE;
RunState prevConvState = IDLE;   // to update LCD only when state changes

// ============================
//       RFID TAG ARRAYS
// ============================

// Number of known tags
const int NUM_TAGS = 6;

// Symbols for tags A..F
const char TAG_SYMBOLS[NUM_TAGS] = {
  'A', 'B', 'C', 'D', 'E', 'F'
};

// Tag IDs as produced by uidToString() -> "x.y.z.w"
const char* TAG_IDS[NUM_TAGS] = {
  "12.80.110.3",      // A
  "178.139.221.208",  // B
  "204.187.101.3",    // C
  "12.86.101.3",      // D
  "66.208.30.83",     // E
  "252.53.92.3"       // F
};

// Column and row for each tag (same index as TAG_IDS / TAG_SYMBOLS)
// A 1 1
// B 2 1
// C 4 1
// D 3 2
// E 2 3
// F 1 3
const int TAG_COL[NUM_TAGS] = {
  1, // A
  2, // B
  4, // C
  3, // D
  2, // E
  1  // F
};

const int TAG_ROW[NUM_TAGS] = {
  1, // A
  1, // B
  1, // C
  2, // D
  3, // E
  3  // F
};

// Current target for this item (set when we read RFID)
int targetCol = -1;
int targetRow = -1;
char lastSymbol = '?';
String lastTag = "";

// Find index of tag in TAG_IDS, or -1 if not found
int findTagIndex(const String &tag) {
  for (int i = 0; i < NUM_TAGS; i++) {
    if (tag == TAG_IDS[i]) {
      return i;
    }
  }
  return -1;
}

// ============================
//       ARM STEPPER HELPERS
// ============================

inline void stepPulse(int delayUs) {
  digitalWrite(STEP_PIN, HIGH);
  delayMicroseconds(delayUs);
  digitalWrite(STEP_PIN, LOW);
  delayMicroseconds(delayUs);
}

inline bool isHomeHit() {
  return (digitalRead(LIMIT_SWITCH_PIN) == LOW);
}

inline int lerpDelay(int startUs, int minUs, long i, long rampSteps) {
  long num = (long)(startUs - minUs) * i;
  long result = startUs - (num / rampSteps);
  return (result < minUs ? minUs : result);
}

void moveStepsTrapezoid(long totalSteps, bool dir) {
  if (totalSteps <= 0) return;

  digitalWrite(DIR_PIN, dir);

  long rampSteps = totalSteps * TRAP_RAMP_FRACTION;
  if (rampSteps < 40) rampSteps = 40;
  if (2 * rampSteps > totalSteps) rampSteps = totalSteps / 2;
  long cruiseSteps = totalSteps - 2 * rampSteps;

  // accel
  for (long i = 0; i < rampSteps; i++) {
    stepPulse(lerpDelay(TRAP_DELAY_START_US, TRAP_DELAY_MIN_US, i, rampSteps));
  }

  // cruise
  for (long i = 0; i < cruiseSteps; i++) {
    stepPulse(TRAP_DELAY_MIN_US);
  }

  // decel
  for (long i = rampSteps; i > 0; i--) {
    stepPulse(lerpDelay(TRAP_DELAY_START_US, TRAP_DELAY_MIN_US, i - 1, rampSteps));
  }

  if (dir == DIR_AWAY_FROM_HOME)
    currentStepPos += totalSteps;
  else
    currentStepPos -= totalSteps;
}

// ============================
//       ARM HOMING FUNCTION
// ============================

void homeArm() {
  Serial.println("Homing arm...");
  lcdStatus("CMD: HOME", "Homing arm...");

  digitalWrite(DIR_PIN, DIR_TOWARD_HOME);
  long safetyCounter = 0;
  while (!isHomeHit()) {
    stepPulse(1000);
    safetyCounter++;
    if (safetyCounter > 100000) break;
  }

  digitalWrite(DIR_PIN, DIR_AWAY_FROM_HOME);
  for (int i = 0; i < BACKOFF_STEPS; i++) {
    stepPulse(1200);
  }

  digitalWrite(DIR_PIN, DIR_TOWARD_HOME);
  while (!isHomeHit()) {
    stepPulse(1500);
  }

  digitalWrite(DIR_PIN, DIR_AWAY_FROM_HOME);
  for (int i = 0; i < 5; i++) {
    stepPulse(1500);
  }

  currentStepPos = 0;
  Serial.println("Arm homed.");
  lcdStatus("CMD: HOME", "Arm homed");
}

// ============================
//       ARM MOVE TO COLUMN
// ============================

void goToColumn(int col) {
  if (col < 1) col = 1;
  if (col > NUM_COLUMNS) col = NUM_COLUMNS;

  long targetSteps = (long)(COL_ABS_CM[col - 1] * STEPS_PER_CM);
  long moveSteps   = targetSteps - currentStepPos;
  bool dir         = (moveSteps >= 0) ? DIR_AWAY_FROM_HOME : DIR_TOWARD_HOME;

  Serial.print("Moving to column ");
  Serial.print(col);
  Serial.print(" -> steps: ");
  Serial.println(moveSteps);

  String line1 = "GOTO COL ";
  line1 += col;
  lcdStatus(line1, "Moving...");

  moveStepsTrapezoid(labs(moveSteps), dir);
}

// ============================
//        SERVO MOTION
// ============================

void servoSmooth(Servo &sv, int &curr, int target, float speed_dps = SERVO_SPEED_DPS_DEFAULT) {
  if (&sv == &s3) {
    sv.write(90);
    s3Pos = 90;
    return;
  }

  target = constrain(target, 0, 180);
  float delayPerDeg = 1000.0f / speed_dps;
  int step = (target > curr) ? 1 : -1;

  while (curr != target) {
    curr += step;
    if ((step > 0 && curr > target) || (step < 0 && curr < target)) {
      curr = target;
    }
    sv.write(curr);
    delay(delayPerDeg);
  }
}

// ============================
//   GLOBAL DEFAULT POSE
// ============================

void goDefaultS5S4() {
  const int SHORT_DELAY = 250;
  const int S5_DELAY    = 400;

  servoSmooth(s1, s1Pos, 100);
  delay(SHORT_DELAY);

  servoSmooth(s2, s2Pos, 90);
  delay(SHORT_DELAY);

  servoSmooth(s5, s5Pos, 10);
  delay(S5_DELAY);

  servoSmooth(s4, s4Pos, 100);
  delay(SHORT_DELAY);

  servoSmooth(s6, s6Pos, 65);
  delay(SHORT_DELAY);

  s3.write(90);
  s3Pos = 90;
  delay(SHORT_DELAY);
}

// ============================
//       PICK FUNCTION
// ============================


void moveServosToPickup() {
  lcdStatus("PICK", "From conveyor");
  // Approach pickup
  servoSmooth(s6, s6Pos, 133);
  servoSmooth(s2, s2Pos, 55);
  servoSmooth(s1, s1Pos, 160);
  servoSmooth(s4, s4Pos, 50);
  servoSmooth(s5, s5Pos, 80);
  servoSmooth(s4, s4Pos, 60);
  servoSmooth(s5, s5Pos, 90);

  delay(300);

  // Grab and lift
  servoSmooth(s1, s1Pos, 90);
  servoSmooth(s5, s5Pos, 10);
  servoSmooth(s2, s2Pos, 120);
  servoSmooth(s6, s6Pos, 60);
  servoSmooth(s4, s4Pos, 110);
}

// ============================
//       ROW FUNCTIONS
// ============================

void row1_put_then_retract() {
  s5.write(60);  delay(600);
  s2.write(95);  delay(600);
  s4.write(90);  delay(600);
  s1.write(160); delay(600);

  s2.write(95);  delay(600);
  s4.write(110); delay(600);
  s5.write(10);  delay(600);

  s2Pos = 95;
  s4Pos = 110;
  s5Pos = 10;
  s1Pos = 120;
}

void row2_put_then_retract() {
  s4.write(40);  delay(600);
  s5.write(40);  delay(600);
  s4.write(30);  delay(600);
  s2.write(75);  delay(600);
  s5.write(70);  delay(600);
  s1.write(160); delay(600);

  s2.write(90);  delay(600);
  s4.write(30);  delay(600);
  s5.write(10);  delay(600);

  s2Pos = 90;
  s4Pos = 30;
  s5Pos = 10;
  s1Pos = 120;
}

void row3_put_then_retract() {
  s5.write(0);   delay(600);
  s4.write(0);   delay(600);
  s5.write(30);  delay(600);
  s2.write(110);   delay(600);
  s5.write(60);  delay(600);
  s2.write(60);   delay(600);
  s5.write(75); delay(600);
  s2.write(10);   delay(600);
  s5.write(80); delay(600);
  s4.write(5);   delay(600);
  s2.write(0);   delay(600);
  s5.write(95); delay(600);
  s4.write(15);   delay(600);
  s1.write(160); delay(600);

  s4.write(0);   delay(600);
  s5.write(70);  delay(600);
  s2.write(80);  delay(600);
  s5.write(40);  delay(600);

  s4Pos = 0;
  s5Pos = 0;
  s2Pos = 45;
  s1Pos = 120;
}
void placeInRow_thenRetract(int row) {
  String line1 = "PLACE R";
  line1 += row;
  lcdStatus(line1, "Placing...");

  switch (row) {
    case 1: row1_put_then_retract(); break;
    case 2: row2_put_then_retract(); break;
    case 3: row3_put_then_retract(); break;
    default:
      Serial.println("Invalid row (1..3).");
      lcdStatus("ERROR", "Row invalid");
      break;
  }
}

// ============================
//       ARM COMMAND HANDLER
// ============================

// نسخة عامة تستقبل أي Stream (USB أو ESP)
String readCommand(Stream &s) {
  s.setTimeout(500);
  String cmd = s.readStringUntil('\n');
  cmd.trim();
  cmd.toUpperCase();
  return cmd;
}

void handleCommand(String cmd) {
  if (cmd.length() == 0) return;

  Serial.print("CMD RECEIVED: ");
  Serial.println(cmd);

  if (cmd.startsWith("HOME")) {
    Serial.println("CMD: HOME");
    lcdStatus("CMD: HOME", "");
    goDefaultS5S4();
    homeArm();
    return;
  }

  if (cmd.startsWith("PICK")) {
    Serial.println("CMD: PICK");
    lcdStatus("CMD: PICK", "");
    moveServosToPickup();
    goDefaultS5S4();
    homeArm();
    return;
  }

  if (cmd.startsWith("GOTO")) {
    int spaceIndex = cmd.indexOf(' ');
    if (spaceIndex < 0) return;

    int col = cmd.substring(spaceIndex + 1).toInt();
    Serial.print("CMD: GOTO ");
    Serial.println(col);
    goToColumn(col);
    goDefaultS5S4();
    homeArm();
    return;
  }

  if (cmd.startsWith("PLACE")) {
    int space1 = cmd.indexOf(' ');
    int space2 = cmd.indexOf(' ', space1 + 1);
    if (space1 < 0 || space2 < 0) return;

    int col = cmd.substring(space1 + 1, space2).toInt();
    int row = cmd.substring(space2 + 1).toInt();

    Serial.print("CMD: PLACE ");
    Serial.print(col);
    Serial.print(" ");
    Serial.println(row);

    goToColumn(col);
    placeInRow_thenRetract(row);
    goDefaultS5S4();
    homeArm();
    return;
  }

  Serial.println("Unknown command.");
  lcdStatus("CMD: UNKNOWN", "");
}

// ============================
//      CONVEYOR HELPERS
// ============================

bool readLDRRaw(uint8_t pin) {
  int raw = digitalRead(pin);
  return LDR_ACTIVE_LOW ? (raw == LOW) : (raw == HIGH);
}

// Stable / filtered LDR (but faster)
bool readLDRStable(uint8_t pin) {
  uint8_t hits = 0;
  for (uint8_t i = 0; i < LDR_SAMPLES; i++) {
    if (readLDRRaw(pin)) hits++;
    delay(LDR_SAMPLE_MS);
  }
  return (hits >= (LDR_SAMPLES / 2 + 1));  // majority
}

String uidToString(const byte* uid, uint8_t len) {
  String s;
  for (uint8_t i = 0; i < len; i++) {
    if (i) s += ".";
    s += String(uid[i]);
  }
  return s;
}

bool tryReadRFID(String &outStr) {
  byte uid[7];
  uint8_t uidLength;
  bool success = nfc.readPassiveTargetID(PN532_MIFARE_ISO14443A, uid, &uidLength, 50);
  if (!success) return false;
  outStr = uidToString(uid, uidLength);
  return true;
}

void enableMotor(bool enable) {
  if (CONV_EN_ACTIVE_LOW) {
    digitalWrite(CONV_EN_PIN, enable ? LOW : HIGH);  // LOW = enable
  } else {
    digitalWrite(CONV_EN_PIN, enable ? HIGH : LOW);  // HIGH = enable
  }
}

// ============================
//         SETUP
// ============================

void setup() {
  Serial.begin(115200);   // USB debug
  ESP_SERIAL.begin(ESP_BAUD); // اتصال مع ESP32

  // LCD init
  lcd.init();
  lcd.backlight();
  lcdStatus("System Start", "Init...");

  Serial.println("=== Arm + Conveyor + PN532 (LCD + tags→cells) ===");

  // Arm stepper pins
  pinMode(DIR_PIN, OUTPUT);
  pinMode(STEP_PIN, OUTPUT);
  pinMode(ENABLE_PIN, OUTPUT);
  pinMode(LIMIT_SWITCH_PIN, INPUT_PULLUP);
  digitalWrite(ENABLE_PIN, LOW);

  // Servos
  s1.attach(S1_PIN); s1.write(s1Pos);
  s2.attach(S2_PIN); s2.write(s2Pos);
  s3.attach(S3_PIN); s3.write(90);
  s4.attach(S4_PIN); s4.write(s4Pos);
  s5.attach(S5_PIN); s5.write(s5Pos);
  s6.attach(S6_PIN); s6.write(s6Pos);

  // Initial arm home + default
  homeArm();
  goDefaultS5S4();

  // Conveyor pins
  pinMode(LDR1_PIN, INPUT_PULLUP);
  pinMode(LDR2_PIN, INPUT_PULLUP);
  pinMode(CONV_EN_PIN, OUTPUT);
  enableMotor(false);

  // Conveyor stepper setup
  conveyorStepper.setMaxSpeed(STEPPER_SPEED);
  conveyorStepper.setAcceleration(STEPPER_ACCEL);

  // PN532 setup
  Serial1.begin(115200);
  nfc.begin();
  uint32_t versiondata = nfc.getFirmwareVersion();
  if (!versiondata) {
    Serial.println("PN532 not found!");
    lcdStatus("ERROR", "PN532 not found");
    while (1);
  }
  nfc.SAMConfig();
  Serial.println("PN532 ready.");
  lcdStatus("Ready", "Waiting LDR1");
}

// ============================
//   STATE → LCD STATUS HELP
// ============================

void updateLCDForState() {
  if (convState == prevConvState) return;
  prevConvState = convState;

  switch (convState) {
    case IDLE:
      lcdStatus("IDLE", "Waiting LDR1");
      break;
    case MOVE_12CM:
      lcdStatus("MOVE 12cm", "");
      break;
    case WAIT_RFID:
      lcdStatus("WAIT RFID", "");
      break;
    case MOVING: {
      String l1 = "MOVING ";
      if (lastSymbol != '?') {
        l1 += lastSymbol;
        l1 += " C";
        l1 += targetCol;
        l1 += "R";
        l1 += targetRow;
      }
      lcdStatus(l1, "To LDR2");
      break;
    }
    case STOPPED:
      lcdStatus("STOPPED", "Clear LDR2");
      break;
  }
}

// ============================
//          LOOP
// ============================

void loop() {
  // Keep conveyor stepper running
  conveyorStepper.run();

  updateLCDForState();

  // Conveyor state machine
  switch (convState) {
    case IDLE:
      enableMotor(false);  // ensure motor off in idle
      if (readLDRStable(LDR1_PIN)) {
        Serial.println("Object detected at LDR1 — moving 12 cm...");
        enableMotor(true);
        conveyorStepper.moveTo(conveyorStepper.currentPosition() + STEPS_PER_12CM);
        convState = MOVE_12CM;
      }
      break;

    case MOVE_12CM:
      if (conveyorStepper.distanceToGo() == 0) {
        Serial.println("12 cm reached — trying to read RFID...");
        convState = WAIT_RFID;
      }
      break;

    case WAIT_RFID: {
      String tag;
      if (tryReadRFID(tag)) {
        Serial.print("RFID Tag read: ");
        Serial.println(tag);

        lastTag = tag;
        int idx = findTagIndex(tag);
        if (idx >= 0) {
          lastSymbol = TAG_SYMBOLS[idx];
          targetCol  = TAG_COL[idx];
          targetRow  = TAG_ROW[idx];

          Serial.print("✅ Known tag: ");
          Serial.print(lastSymbol);
          Serial.print(" -> col ");
          Serial.print(targetCol);
          Serial.print(" row ");
          Serial.println(targetRow);

          String line1 = "TAG:";
          line1 += lastSymbol;
          String line2 = "C";
          line2 += targetCol;
          line2 += " R";
          line2 += targetRow;
          lcdStatus(line1, line2);
        } else {
          Serial.println("⚠ Unknown tag (not in array).");
          lcdStatus("TAG UNKNOWN", "");
          lastSymbol = '?';
          targetCol = -1;
          targetRow = -1;
        }

        conveyorStepper.moveTo(999999); // move forward continuously
        Serial.println("Conveyor moving until LDR2 is triggered...");
        convState = MOVING;
      }
      break;
    }

    case MOVING:
      if (readLDRStable(LDR2_PIN)) {
        Serial.println("LDR2 detected object — INSTANT stop + pick with arm.");
        lcdStatus("LDR2 HIT", "Stop & pick");

        // Instant electrical stop: disable driver
        enableMotor(false);

        // Stop AccelStepper logically
        conveyorStepper.stop();
        conveyorStepper.setCurrentPosition(conveyorStepper.currentPosition());

        delay(50);  // small settle time

        // 1) Pick from conveyor
        moveServosToPickup();

        // 2) Place in mapped cell if valid
        if (targetCol > 0 && targetRow > 0) {
          Serial.print("Placing item at col ");
          Serial.print(targetCol);
          Serial.print(", row ");
          Serial.println(targetRow);

          String line1 = "PLACE ";
          line1 += lastSymbol;
          String line2 = "C";
          line2 += targetCol;
          line2 += " R";
          line2 += targetRow;
          lcdStatus(line1, line2);

          goToColumn(targetCol);
          placeInRow_thenRetract(targetRow);
        } else {
          Serial.println("⚠ No valid targetCol/targetRow set for this item.");
          lcdStatus("ERROR", "No target cell");
        }

        // 3) Return arm to default and home X-axis
        goDefaultS5S4();
        homeArm();

        // Reset target for next item
        targetCol = -1;
        targetRow = -1;
        lastSymbol = '?';
        lastTag = "";

        Serial.println("Conveyor stopped, item placed — waiting for object to clear LDR2.");
        convState = STOPPED;
      }
      break;

    case STOPPED:
      enableMotor(false);   
      if (!readLDRStable(LDR2_PIN)) {
        Serial.println("Object cleared — back to idle.");
        conveyorStepper.setCurrentPosition(0);
        convState = IDLE;
      }
      break;
  }

  // ========= استقبال الأوامر =========

  if (Serial.available()) {
    String cmd = readCommand(Serial);
    handleCommand(cmd);
  }

  if (ESP_SERIAL.available()) {
    String cmd = readCommand(ESP_SERIAL);
    handleCommand(cmd);
  }
}
// ---- Pins ----
const int DIR_PIN          = 2;
const int STEP_PIN         = 3;
const int ENABLE_PIN       = 4;
const int LIMIT_SWITCH_PIN = 10;   // Active LOW with INPUT_PULLUP

// ---- Geometry / Steps ----
const int STEPS_PER_CM   = 50;   // 200 steps / 4 cm = 50 steps/cm
const int CELL_CM        = 9;    // each cell = 9 cm
const int STEPS_PER_CELL = STEPS_PER_CM * CELL_CM;  // 450
const int NUM_CELLS      = 5;

// ---- Motion timing ----
const int STEP_DELAY_US_FAST  = 700;   // fast homing initial
const int STEP_DELAY_US_SLOW  = 1500;  // slow final homing
const int BACKOFF_STEPS       = 50;

// Travel (forward to cells)
const int TRAP_DELAY_START_US = 1500;  // smooth start
const int TRAP_DELAY_MIN_US   = 600;   // top speed
const float TRAP_RAMP_FRACTION = 0.20f;

// Homing slow-down profile
const int HOMING_SLOW_STEPS = 200;   // how many last steps to slow down
const int HOMING_FAST_DELAY = 700;   // start of return
const int HOMING_SLOW_DELAY = 1600;  // final approach delay

// ---- Directions ----
const bool DIR_AWAY_FROM_HOME = HIGH;
const bool DIR_TOWARD_HOME    = LOW;

// ---- Helpers ----
inline void stepPulse(int delayUs) {
  digitalWrite(STEP_PIN, HIGH);
  delayMicroseconds(delayUs);
  digitalWrite(STEP_PIN, LOW);
  delayMicroseconds(delayUs);
}

inline bool isHomeHit() {
  return digitalRead(LIMIT_SWITCH_PIN) == LOW; // active LOW
}

// ---- Trapezoid Move ----
inline int lerpDelay(int startUs, int minUs, long i, long rampSteps) {
  if (rampSteps <= 0) return minUs;
  long num = (long)(startUs - minUs) * i;
  long delta = num / rampSteps;
  int d = startUs - (int)delta;
  if (d < minUs) d = minUs;
  return d;
}

void moveStepsTrapezoid(long totalSteps, bool dir) {
  if (totalSteps <= 0) return;

  digitalWrite(DIR_PIN, dir ? HIGH : LOW);
  long rampSteps = (long)(totalSteps * TRAP_RAMP_FRACTION);
  if (rampSteps < 40) rampSteps = 40;
  if (2 * rampSteps > totalSteps) rampSteps = totalSteps / 2;
  long cruiseSteps = totalSteps - 2 * rampSteps;

  // Accelerate
  for (long i = 0; i < rampSteps; i++) {
    int d = lerpDelay(TRAP_DELAY_START_US, TRAP_DELAY_MIN_US, i, rampSteps);
    stepPulse(d);
  }

  // Cruise
  for (long i = 0; i < cruiseSteps; i++) stepPulse(TRAP_DELAY_MIN_US);

  // Decelerate
  for (long i = rampSteps; i > 0; i--) {
    int d = lerpDelay(TRAP_DELAY_START_US, TRAP_DELAY_MIN_US, i - 1, rampSteps);
    stepPulse(d);
  }
}

// ---- Smooth Homing ----
void homeArm() {
  // Move fast toward switch first
  digitalWrite(DIR_PIN, DIR_TOWARD_HOME);
  long stepsCounter = 0;

  // move until close to switch
  while (!isHomeHit()) {
    // gradually slow as we approach the switch
    int delayNow = (stepsCounter < HOMING_SLOW_STEPS)
        ? HOMING_FAST_DELAY
        : map(stepsCounter, HOMING_SLOW_STEPS, HOMING_SLOW_STEPS * 3, HOMING_FAST_DELAY, HOMING_SLOW_DELAY);

    if (delayNow > HOMING_SLOW_DELAY) delayNow = HOMING_SLOW_DELAY;

    stepPulse(delayNow);
    stepsCounter++;
  }

  // Back off slightly
  digitalWrite(DIR_PIN, DIR_AWAY_FROM_HOME);
  for (int i = 0; i < BACKOFF_STEPS; i++) stepPulse(1000);
  delay(5);

  // Re-approach slowly for precise home
  digitalWrite(DIR_PIN, DIR_TOWARD_HOME);
  while (!isHomeHit()) {
    stepPulse(HOMING_SLOW_DELAY);
  }

  // Relieve switch pressure
  digitalWrite(DIR_PIN, DIR_AWAY_FROM_HOME);
  for (int i = 0; i < 5; i++) stepPulse(HOMING_SLOW_DELAY);
}

// ---- Cell Travel ----
void goToCellFromHome(int cellIndex) {
  long targetSteps = (long)cellIndex * STEPS_PER_CELL;
  moveStepsTrapezoid(targetSteps, DIR_AWAY_FROM_HOME);
}

// ---- Setup ----
void setup() {
  Serial.begin(115200);
  pinMode(DIR_PIN, OUTPUT);
  pinMode(STEP_PIN, OUTPUT);
  pinMode(ENABLE_PIN, OUTPUT);
  pinMode(LIMIT_SWITCH_PIN, INPUT_PULLUP);

  digitalWrite(ENABLE_PIN, LOW); // enable driver
  Serial.println("ðŸ Homing...");
  homeArm();
  Serial.println("âœ… Homed. Starting sequence...");
}

// ---- Main Loop ----
void loop() {
  for (int cell = 1; cell <= NUM_CELLS; cell++) {
    Serial.print("âž¡ Moving to cell ");
    Serial.println(cell);

    goToCellFromHome(cell);

    Serial.println("â¸ Waiting 2 seconds at cell...");
    delay(2000);

    Serial.println("â†© Returning to home slowly...");
    homeArm();

    delay(500);
  }

  Serial.println("âœ… All cells completed. Restarting in 2 seconds...");
  delay(2000);
}
